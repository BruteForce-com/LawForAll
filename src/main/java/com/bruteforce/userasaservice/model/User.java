/**
 * Represents a user in the system with authentication and profile information.
 *
 * <p>This entity is the central identity model that supports multiple authentication methods,
 * including email/password and OAuth providers. It serves as the base for role-based access control
 * with support for PUBLIC, ADMIN, and LAWYER roles.</p>
 *
 * <h3>Key Features:</h3>
 * <ul>
 *   <li>Supports both traditional (email/password) and OAuth authentication</li>
 *   <li>Role-based access control with default to the PUBLIC role</li>
 *   <li>Email and phone verification status tracking</li>
 *   <li>Account activation/deactivation support</li>
 *   <li>Automatic audit fields (createdAt, updatedAt)</li>
 *   <li>Optional lawyer profile association for users with LAWYER role</li>
 * </ul>
 *
 * <h3>Database Constraints:</h3>
 * <ul>
 *   <li>Unique constraint on (oauth_provider, oauth_id) for OAuth authentication</li>
 *   <li>Unique constraint on email, username, and phoneNumber</li>
 *   <li>Indexes on frequently queried fields for performance</li>
 * </ul>
 *
 * @author shivaverabandi - BruteForce.com
 * @version 1.0
 * @since 2025-10-22
 * @see Role
 * @see LawyerProfile
 */

package com.bruteforce.userasaservice.model;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import java.time.LocalDateTime;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.annotations.UuidGenerator;

import java.util.UUID;

@Entity
@Table(
        name = "users",
        indexes = {
                @Index(name = "idx_user_username", columnList = "userName", unique = true),
                @Index(name = "idx_user_phone", columnList = "phoneNumber", unique = true),
                @Index(name = "idx_user_role_status", columnList = "role, isActive"),
                @Index(name = "idx_oauth", columnList = "oauthProvider, oauthId")
        },
        uniqueConstraints = {
                @UniqueConstraint(
                        name = "uk_oauth_provider_id",
                        columnNames = {"oauthProvider", "oauthId"}
                )
        }
)
public class User {
    /**
     * The user's unique identifier. Automatically generated as a UUID.
     *
     * <p>This is the primary key of the users table and is not updatable once set.
     * The UUID is generated by Hibernate using the @UuidGenerator.</p>
     */
    @Id
    @GeneratedValue
    @UuidGenerator
    @Column(name = "user_id", updatable = false, nullable = false, columnDefinition = "UUID")
    private UUID userId;

    /**
     * The user's email address. Required and must be unique across all users.
     *
     * <p>Used for authentication and communication. Must be a valid email format.
     * The email is case-insensitive and will be stored in lowercase.</p>
     */
    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    @Column(nullable = false, unique = true, length = 255)
    private String email;

    /**
     * The hashed password for the user. Required for email/password authentication.
     *
     * <p>This should always store the hashed password, never plain text.
     * The hashing should be done using a strong cryptographic hash function like BCrypt.</p>
     */
    @NotBlank(message = "Password hash is required")
    @Column(nullable = false)
    private String passwordHash;

    /**
     * The user's full legal name. Required for all user accounts.
     *
     * <p>This is the user's complete name as it should appear on official documents.
     * Maximum of length is 255 characters.</p>
     */
    @NotBlank(message = "Full name is required")
    @Column(nullable = false, name = "full_name", length = 255)
    private String fullName;

    /**
     * The user's unique username. Required and must be unique across all users.
     *
     * <p>Used for @mentions and user identification. Must be between 3 and 50 characters.
     * Only alphanumeric characters, dots, underscores, and hyphens are allowed.</p>
     */
    @NotBlank(message = "Username is required")
    @Column(unique = true, nullable = false, length = 50, name = "user_name")
    private String userName;

    /**
     * The user's phone number in valid format. Optional but must be unique if provided.
     */
    @Column(length = 25, unique = true)
    private String phoneNumber;

    /**
     * The user's role in the system. Defaults to PUBLIC.
     *
     * <p>Determines the user's permissions and access levels within the application.
     * Possible values are defined in the {@link Role} enum.</p>
     *
     * @see Role
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.PUBLIC;

    /**
     * The OAuth provider name if the user signed up via OAuth (e.g., "google", "facebook").
     *
     * <p>This field is part of the composite unique constraint with oauthId.
     * Null for users who signed up with email/password.</p>
     */
    @Column(name = "oauth_provider", length = 50)
    private String oauthProvider;

    /**
     * The user's unique identifier from the OAuth provider.
     *
     * <p>This is the external ID provided by the OAuth provider (e.g., Google's 'sub' claim).
     * Part of the composite unique constraint with oauthProvider.</p>
     */
    @Column(name = "oauth_id", length = 100)
    private String oauthId;

    /**
     * Indicates whether the user's email or phone number has been verified.
     *
     * <p>Defaults to false. Should be set to true after the user verifies their email/phone.</p>
     */
    @Column(name = "is_verified", nullable = false)
    private Boolean isVerified = false;

    /**
     * Indicates whether the user account is active.
     *
     * <p>Set to false deactivate the account instead of deleting it.
     * Deactivated users cannot log in but their data is preserved.</p>
     */
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    /**
     * The date and time when the user account was created.
     *
     * <p>Automatically set by Hibernate when the entity is first persisted.
     * Cannot be modified after creation.</p>
     */
    @CreationTimestamp
    @Column(name = "created_at", updatable = false, nullable = false)
    private LocalDateTime createdAt;

    /**
     * The date and time when the user account was last updated.
     *
     * <p>Automatically updated by Hibernate whenever the entity is modified.
     * Cannot be set manually.</p>
     */
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * The lawyer profile associated with this user, if the user has the LAWYER role.
     *
     * <p>This is a one-to-one relationship where the LawyerProfile is the owning side.
     * The profile is automatically deleted if the user is deleted (orphanRemoval = true).
     * Loaded lazily to improve performance.</p>
     *
     * @see LawyerProfile
     */
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private LawyerProfile lawyerProfile;

    // Getters and setters would go here
}